<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Edge rule - AutoTrimmer Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AutoTrimmer Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="edge-rules"><a class="header" href="#edge-rules">Edge rules</a></h1>
<p>Edge rules determine where trims are added onto a 3D model.
Without edge rules, your model will not get any trims added onto it.</p>
<p>An edge rule specifies when trims get added and which trims get added.
The complicated part of this is specifying <em>when</em> trims get added,
the “condition”.
The condition consists of a bit of code that says exactly when
trims should get added.</p>
<p>Despite needing some code,
you generally don't need to be a computer whiz to create edge rules.
You can just paste in some code from the <a href="../recipes.html">recipes</a> and
<a href="#surface-constants">adjust the surface names</a>
to your situation, and that should be good enough for a lot of
situations.</p>
<p>An in-depth understanding of the code for edge rule conditions
is not necessary. They're pretty short, and you can make do with a shallow
understanding.</p>
<p>An edge rule is evaluated once for every edge of every face.
Edge rules are evaluated in-order, with the ones appearing first on the list
being evaluated first.</p>
<p><img src="screenshots/edge_rule.png" alt="" /></p>
<hr />
<h2 id="general-settings"><a class="header" href="#general-settings">General settings</a></h2>
<h3 id="condition"><a class="header" href="#condition">Condition</a></h3>
<p><em>Code that determines when the trims should be added to an edge.</em></p>
<p>This snippet of code determines when the trims should be added.
It's too much to explain here, so there's a whole section for it.
Take a look at the <a href="#condition-code">condition section</a>.</p>
<h3 id="add-trim-here-optional"><a class="header" href="#add-trim-here-optional">Add trim here <em>(optional)</em></a></h3>
<p><em>Which trim to add to the first side of the edge.</em></p>
<p>This determines which trim gets added to the current face
if the <a href="#condition">condition</a> passes
(the “self” face in the condition).</p>
<p><em>Trim names are sensitive to capitals and spaces. For example,
if your trim is called “brick_trim” and you fill in “Brick_trim” instead, you'll
get an error, because of the mismatch in the capital letter B.</em></p>
<h3 id="add-trim-at-neighbor-optional"><a class="header" href="#add-trim-at-neighbor-optional">Add trim at neighbor <em>(optional)</em></a></h3>
<p><em>Which trim to add to the second side of the edge.</em></p>
<p>This determines which trim gets added to the neighboring face
if the <a href="#condition">condition</a> passes
(the “neighbor” face in the condition).
If the current face does not have a neighbor, this is ignored.</p>
<p><em>Trim names are sensitive to capitals and spaces. For example,
if your trim is called “brick_trim” and you fill in “Brick_trim” instead, you'll
get an error, because of the mismatch in the capital letter B.</em></p>
<h3 id="no-more-trims-here"><a class="header" href="#no-more-trims-here">No more trims here</a></h3>
<p><em>Whether anymore trims should be added to the first side of the edge.</em></p>
<p>When the <a href="#condition">condition</a> passes and this setting is enabled,
no more edge rules will be evaluated for this edge from the current face.
By that I mean: For the edge that passed the condition,
the current face will never appear as <code>self</code> anymore.
It can still appear as <code>neighbor</code> unless
“<a href="#no-more-trims-at-neighbor">no more trims at neighbor</a>” is also checked.</p>
<p>Because edge rules are evaluated in-order, this option only affects edge rules
that come after the current edge rule in the list.</p>
<p>Unless you're specifically in a situation where you want to have multiple trims
that attach to this edge, you should leave this enabled.</p>
<h3 id="no-more-trims-at-neighbor"><a class="header" href="#no-more-trims-at-neighbor">No more trims at neighbor</a></h3>
<p><em>Whether anymore trims should be added to the second side of the edge.</em></p>
<p>This is mostly the same as “<a href="#no-more-trims-here">no more trims here</a>”,
except that it prevents the neighboring face from appearing as <code>self</code>
(instead of the current face).</p>
<p>If this is enabled and “<a href="#no-more-trims-here">no more trims here</a>” is disabled,
the neighboring face can still appear as <code>neighbor</code>, but never as <code>self</code>.</p>
<p>If an edge rule can apply to both a face and its neighbor,
then I really can't tell you which of the two faces will have the edge
rule evaluated first and which
one would be blocked by “no more trims at neighbor”. It depends on the 3D model
and in what order the model's internal data is stored.
In practice that means it's basically random.</p>
<hr />
<h2 id="condition-code"><a class="header" href="#condition-code">Condition code</a></h2>
<p>An edge rule uses a snippet of code to check when its trims should
be applied.</p>
<p>For its conditions,
AutoTrimmer uses a tiny scripting language that resembles Python and GDScript.
It only supports expressions
(the kind of code that you can put in an if-statement) —
you can't create new variables or functions.</p>
<p>Below is an example. The <code>self</code> trim is green and the <code>neighbor</code> trim is blue.
Notice how only the sort-of-sharp edges are given a trim by this edge rule.
That's because concave corners (like the corners at the bottom of the walls)
have a negative angle in AutoTrimmer.
This rule only applies to edges with an angle greater
than 40° — which excludes all negative angles.</p>
<pre><code class="language-python">self.surface == BRICK  # The current face is brick...
and neighbor.surface != BRICK  # And the neighboring face is not brick...
and angle &gt; 40  # And the angle between the two faces is greater than 40 degrees
</code></pre>
<p><img src="screenshots/conditions_example_1.png" alt="" /></p>
<h3 id="approximately-equals"><a class="header" href="#approximately-equals">Approximately equals</a></h3>
<p>Although the scripting language strongly resembles Python &amp; GDScript,
there is one feature that those languages don't have:
AutoTrimmer has the operator <code>~=</code>, which means “approximately equals”.
This operator is useful because software like Blender is not completely exact,
so checking whether two coordinates or two directions are <em>exactly</em> equal will
often not work the way you would like it to.</p>
<p>The <code>~=</code> operator is <code>True</code> if its two operands are <strong>almost</strong> exactly the same.
The amount of error that it tolerates is really very small.
It's a substitute for the <code>==</code> operator for situations where the operands can
be very slightly wrong, due to precision problems.</p>
<p>There's also the “not approximately equal” operator <code>!~=</code>.
It gives the opposite of what <code>~=</code> would give.</p>
<h3 id="surface-constants"><a class="header" href="#surface-constants">Surface constants</a></h3>
<p>In code, each surface is referred to by a constant number.
That constant number is given a name
that you can use to refer to the surface in code.
For example, here's a rule that finds all edges between a brick surface
and a dirt surface:</p>
<pre><code class="language-python">self.surface == BRICK and neighbor.surface == DIRT
</code></pre>
<p><img src="screenshots/conditions_example_2.png" alt="" /></p>
<p>In code, the name of the surface is the same as its normal name,
but in UPPER_SNAKE_CASE.
If you keep the capitalization of your surface names somewhat normal,
the upper snake case name will probably match your intuition.</p>
<p>Here's some examples of how names are turned into
upper snake case:</p>
<div class="table-wrapper"><table><thead><tr><th>Surface name</th><th>UPPER_SNAKE_CASE_NAME</th></tr></thead><tbody>
<tr><td>brick</td><td>BRICK</td></tr>
<tr><td>Brick</td><td>BRICK</td></tr>
<tr><td>BRICK</td><td>BRICK</td></tr>
<tr><td>grey brick</td><td>GREY_BRICK</td></tr>
<tr><td>GreyBrick</td><td>GREY_BRICK</td></tr>
<tr><td>grey_brick</td><td>GREY_BRICK</td></tr>
<tr><td>Grey_Brick</td><td>GREY_BRICK</td></tr>
<tr><td>GREY_BRICK</td><td>GREY_BRICK</td></tr>
<tr><td>greybrick</td><td>GREYBRICK</td></tr>
<tr><td>dvd player grey</td><td>DVD_PLAYER_GREY</td></tr>
<tr><td>DVD_PLAYER_GREY</td><td>DVD_PLAYER_GREY</td></tr>
</tbody></table>
</div>
<p>However! If you use mix different types of capitalization it
doesn't work so well:</p>
<div class="table-wrapper"><table><thead><tr><th>Surface name</th><th>UPPER_SNAKE_CASE_NAME</th></tr></thead><tbody>
<tr><td>DVD player grey</td><td>D_V_D_PLAYER_GREY</td></tr>
<tr><td>DVDPlayerGrey</td><td>D_V_D_PLAYER_GREY</td></tr>
<tr><td>DVDplayergrey</td><td>D_V_DPLAYERGREY</td></tr>
<tr><td>grey_BRICK</td><td>GREY_B_R_I_C_K</td></tr>
<tr><td>GREy_BRICK</td><td>G_R_EY_B_R_I_C_K</td></tr>
<tr><td>GrEyBrIcK</td><td>GR_EY_BR_IC_K</td></tr>
</tbody></table>
</div>
<p>Try to stick to one type of capitalization (and don't capitalize it in a
weird way).</p>
<h3 id="overview-of-variables"><a class="header" href="#overview-of-variables">Overview of variables</a></h3>
<p>This is the list of variables that you can directly use in an edge rule.
The variables <code>self</code> and <code>neighbor</code> have useful properties inside, which are
documented in the <a href="#overview-of-face">Face</a> section.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Short description</th></tr></thead><tbody>
<tr><td><a href="#self">self</a></td><td><a href="#overview-of-face">Face</a></td><td>The current face.</td></tr>
<tr><td><a href="#neighbor">neighbor</a></td><td><a href="#overview-of-face">Face</a>?</td><td>The neighboring face, if it exists.</td></tr>
<tr><td><a href="#angle">angle</a></td><td>number?</td><td>The angle between the current face and its neighbor, if there is a neighbor.</td></tr>
<tr><td>has_neighbor</td><td>boolean</td><td><code>True</code> when <code>self</code> has a neighboring face.</td></tr>
</tbody></table>
</div>
<h3 id="self"><a class="header" href="#self">self</a></h3>
<p>The global variable <code>self</code> gives you the current <a href="#overview-of-face">Face</a>.</p>
<h3 id="neighbor"><a class="header" href="#neighbor">neighbor</a></h3>
<p>The global variable <code>neighbor</code> gives you the neighboring <a href="#overview-of-face">Face</a>.
If there is no <code>neighbor</code>, but <code>neighbor</code> is necessary to compute
your condition, then that counts as the condition not passing.</p>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<p>This condition will pass for the edges that are between a brick face and a
dirt face. This condition will not pass for faces with no neighbor, because
<code>neighbor</code> is necessary to compute the rule.</p>
<pre><code class="language-python">self.surface == BRICK and neighbor.surface == DIRT
</code></pre>
<hr />
<p>This condition will pass for the edges that are inbetween a brick face and any
face that isn't brick. This condition will not pass for faces with no
neighbor, because <code>neighbor</code> is necessary to compute the rule.</p>
<pre><code class="language-python">self.surface == BRICK and neighbor.surface != BRICK
</code></pre>
<hr />
<p>This condition will pass for the edges where there either is no neighbor,
or where the neighboring face isn't a brick surface.</p>
<pre><code class="language-python">self.surface == BRICK and (not has_neighbor or neighbor.surface != BRICK)
</code></pre>
<p>It's a little complicated, but here's why this works when there's no
neighbor, even though it uses the variable "neighbor":</p>
<p>In the expression "A or B", the part "B" is not looked at when "A" is True.
It isn't necessary to look at "B", because "True or ???" is always going to be
"True" in the end. After all, the result of "True or True" is "True",
and the result of "True or False" is also "True".</p>
<p>This edge rule still works if there is no neighbor, because the part that uses
"neighbor" is only looked at if there is a neighbor. The rule first checks if
a neighbor exists before using the variable "neighbor".</p>
<p>Something similar applies to "A and B": An expression like "False and ???" is
always going to give the result "False", so in the case of "A and B", it won't
look at "B" if "A" is "False".</p>
<p>The example on the right is using the code from this last example.
Notice how the bottom
edge of the slope also gets decorated, even though the face does not have a
neighbor there.</p>
<p><img src="screenshots/conditions_example_3.png" alt="" /></p>
<h3 id="angle"><a class="header" href="#angle">angle</a></h3>
<p>The global variable <code>angle</code> gives you the angle between <code>self</code> and <code>neighbor</code>
in degrees. The variable <code>angle</code> is always between -180° and 180°</p>
<div class="table-wrapper"><table><thead><tr><th>Angle</th><th>Short description</th></tr></thead><tbody>
<tr><td>0</td><td><code>self</code> and <code>neighbor</code> are completely flat. They face the exact same direction.</td></tr>
<tr><td>90</td><td>This is a convex right angle, like an edge of a cube. It's kind of pointy.</td></tr>
<tr><td>-90</td><td>This is a concave right angle, like a corner of a room. It's the kind of corner where dust builds up if you don't clean your stuff properly.</td></tr>
</tbody></table>
</div>
<p><strong>Because 3D editing software is not perfectly exact,
you should not use exact equality.</strong>
You should be pretty approximate when checking angles.
For example instead of <code>angle == 45</code> (to see if the angle is 45°),
you might want to use <code>40 &lt; angle and angle &lt; 50</code>, which adds 5° of leeway in
both directions.</p>
<p>If there is no <code>neighbor</code> and <code>angle</code> is necessary to compute
your condition, then the edge rule fails.
Please note that this happens <em>only</em> if <code>angle</code> is
necessary in the calculation.
This is discussed in more detail in the last example of</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples:</a></h4>
<p>This edge rule will only succeed for faces that…</p>
<ul>
<li>… have a neighbor (implicit, because it uses "angle"), and…</li>
<li>… have an angle to their neighbor that is greater than 30 degrees.</li>
</ul>
<pre><code class="language-python">self.surface == DIRT and angle &gt; 30
</code></pre>
<p>Notice how this rule adds a trim at the top of the ramp, but not at the bottom
of the ramp:
This is because the angle at the top of the ramp is 35°,
and the angle at the bottom of the ramp is -35° (note the minus!)</p>
<p><img src="screenshots/conditions_example_4.png" alt="" /></p>
<hr />
<p>In the next code snippet, the second line of code is <code>True</code> if either…</p>
<ul>
<li>… this face has no neighbor, or…</li>
<li>… the angle is not very steep (between 40 and -40 degrees).</li>
</ul>
<pre><code class="language-python">self.surface == BRICK
and (not has_neighbor or (-40 &lt; angle and angle &lt; 40)) 
</code></pre>
<p>Notice how only the flat edges get a trim added between them,
and the sides of the diagonal brick wall do not get trims.
For this example it's important to understand
that Godot turns all faces into triangles before they get to
AutoTrimmer. That's why all of the faces are triangles.</p>
<p><img src="screenshots/conditions_example_5.png" alt="" /></p>
<h3 id="overview-of-global-functions"><a class="header" href="#overview-of-global-functions">Overview of global functions</a></h3>
<p>These functions are available for use in edge rules.</p>
<p><strong>Author's note</strong>: Only <code>abs(number)</code> has been useful to me so far.
The rest of these functions haven't been useful at all,
but they're there if you need them.</p>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th style="text-align: center">Result</th><th>Short description</th></tr></thead><tbody>
<tr><td>abs(number)</td><td style="text-align: center">number</td><td>In mathematics, the absolute turns negative numbers into positive numbers. Positive numbers stay the same.</td></tr>
<tr><td>abs(vector)</td><td style="text-align: center"><a href="#overview-of-vector2-and-vector3">vector</a></td><td>This applies <code>abs(number)</code> to each element of the vector.</td></tr>
<tr><td>normalize(vector)</td><td style="text-align: center"><a href="#overview-of-vector2-and-vector3">vector</a></td><td>In mathematics, normalizing a vector changes its length to 1. As a special case, if you pass in a zero vector, you get a zero vector out.</td></tr>
<tr><td>vec2(number, number)</td><td style="text-align: center"><a href="#overview-of-vector2-and-vector3">Vector2</a></td><td>Creates a new <a href="#overview-of-vector2-and-vector3">Vector2</a>.</td></tr>
<tr><td>vec3(number, number, number)</td><td style="text-align: center"><a href="#overview-of-vector2-and-vector3">Vector3</a></td><td>Creates a new <a href="#overview-of-vector2-and-vector3">Vector3</a>.</td></tr>
<tr><td>sin(number)</td><td style="text-align: center">number</td><td>Computes the sine.</td></tr>
<tr><td>cos(number)</td><td style="text-align: center">number</td><td>Computes the cosine.</td></tr>
<tr><td>tan(number)</td><td style="text-align: center">number</td><td>Computes the tangent.</td></tr>
<tr><td>asin(number)</td><td style="text-align: center">number</td><td>Essentially the opposite of <code>sin</code>.</td></tr>
<tr><td>acos(number)</td><td style="text-align: center">number</td><td>Essentially the opposite of <code>cos</code>.</td></tr>
<tr><td>atan(number)</td><td style="text-align: center">number</td><td>Essentially the opposite of <code>tan</code>.</td></tr>
</tbody></table>
</div>
<h3 id="overview-of-face"><a class="header" href="#overview-of-face">Overview of Face</a></h3>
<p>The type Face gives you information about one of the faces next to the current
edge.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th style="text-align: center">Type</th><th>Short description</th></tr></thead><tbody>
<tr><td><a href="#surface">surface</a></td><td style="text-align: center">number</td><td>Which surface the face belongs to. Useful for comparing against <a href="#surface-constants">surface constants</a>.</td></tr>
<tr><td><a href="#dir">dir</a></td><td style="text-align: center"><a href="#overview-of-vector2-and-vector3">Vector3</a></td><td>The direction of the face.</td></tr>
<tr><td><a href="#uv_dir">uv_dir</a></td><td style="text-align: center"><a href="#overview-of-vector2-and-vector3">Vector2</a></td><td>The direction of the texture.</td></tr>
</tbody></table>
</div>
<h3 id="surface"><a class="header" href="#surface">surface</a></h3>
<p>Each surface is associated with a constant number.
The <code>surface</code> property of a Face gives you the surface number of that
face.
It's very useful for comparing against <a href="#surface-constants">surface constants</a>.
Most likely all of your edge rules will make use of this property.</p>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples</a></h4>
<pre><code class="language-python">self.surface == DIRT
</code></pre>
<p><img src="screenshots/conditions_example_face_surface.png" alt="" /></p>
<h3 id="dir"><a class="header" href="#dir">dir</a></h3>
<p>The face property <code>dir</code> gives the direction of the face.
Specifically, it's the direction that's perpendicular to the current edge
and which points inwards, towards this face.
The direction <code>dir</code> is in the 3D model's local space (not world space — it ignores the rotation of the 3D model instance).</p>
<h4 id="examples-3"><a class="header" href="#examples-3">Examples</a></h4>
<pre><code class="language-python">self.dir.y &gt; 0.8
</code></pre>
<p>Notice how the green trims all have a perpendicular that points mostly upwards.
<img src="screenshots/conditions_example_face_dir.png" alt="" /></p>
<h3 id="uv_dir"><a class="header" href="#uv_dir">uv_dir</a></h3>
<p>This gives you the direction of the texture.
It's like <a href="#dir">dir</a>, but in texture space instead of world space.</p>
<p>Basically,
you can use this to check whether an edge is aligned with the texture.
I use this in the <a href="">roof trick</a> to differentiate between top ridges and
side ridges.</p>
<p>Here's a more precise explanation:
The property <code>uv_dir</code> is the direction <em>in texture space</em>
that's perpendicular to the current edge <em>(in texture space)</em>
and which points inwards, towards this face <em>(in texture space)</em>.</p>
<p><strong>UVs explained</strong>: <em>To draw textures onto your 3D model, the computer
needs to know which parts of the texture go where.
This is determined by UV coordinates.
Each corner of a face is given a coordinate on the texture, and the computer
will then fill in the face with the part of the texture that's between those
coordinates.</em></p>
<p><em><strong>It's very important to know</strong></em> that in Godot,
the y-axis goes <em>downwards</em> in texture space instead of upwards.
That means that positive values of y are downwards, and negative values of y are
upwards.</p>
<h4 id="examples-4"><a class="header" href="#examples-4">Examples</a></h4>
<pre><code class="language-python">self.surface == BRICK and self.uv_dir.y ~= 1
</code></pre>
<p>This example uses the <a href="#approximately-equals">approximately equals</a> operator
<code>~=</code>.</p>
<p>For this example I replaced the brick texture with a test texture.
Notice how all the green trims are pointing exactly downwards in texture space.
<img src="screenshots/conditions_example_face_uv_dir.png" alt="" /></p>
<h3 id="overview-of-vector2-and-vector3"><a class="header" href="#overview-of-vector2-and-vector3">Overview of Vector2 and Vector3</a></h3>
<p>In mathematics, a vector is a couple of numbers slapped together into one "thing".
Here's an example of a 3D vector: (1.1, 0, -2.2).
Now, I realize that
that's a pretty boring example, but that's what vectors look like.
It's just a couple of numbers put together.</p>
<p>Vectors can be used for all sorts of purposes,
but here are the three most common uses in geometry:</p>
<ul>
<li>A <strong>position</strong>. For example, if we have three numbers, we can use those
numbers as a
3D coordinate. You've probably had Cartesian coordinates in school, so I won't
go into detail about how that works, but in short:
One of the three numbers is the distance right/left, another one is up/down,
and the last one is backward &amp; forward (the order of the numbers
differs per game engine). Put those three coordinate numbers
into a vector, and you have yourself a “position vector”.</li>
<li>A <strong>difference in positions</strong>. Basically it's saying,
if we are at point A, how many steps do we need to take to get to point B?
In 3D, we measure the amount of steps in each of the three dimensions
separately, and those three numbers make up your 3D difference vector.</li>
<li>A <strong>direction</strong>. If we have a difference in positions, we can say that we
don't really care about the length of that difference, only the direction of
it. If we throw out the length (by changing the length to 1),
what you get is called a “direction vector”.</li>
</ul>
<p>I'm not going to go into detail about vectors and linear algebra here, because
this is not exactly the right place to start writing a mathematics book.
That said, while writing edge rules, we only really use direction vectors.</p>
<p>The direction vectors that you get from <a href="#overview-of-face">Face</a>
always have a length of 1.
So, if you want to check if a direction goes upwards, you can use a tiny code
snippet like <code>dir.y &gt; 0.9</code>, which will be <code>True</code> whenever the direction is
strongly upwards.
Since the total length of <code>dir</code> is always 1,
whenever the y-coordinate of <code>dir</code> is greater than 0.9,
the x and z-coordinate must be pretty small.
So a direction for which <code>dir.y &gt; 0.9</code> is definitely an
upwards direction.
You can replace "0.9" with a smaller number if you don't need the direction
to be so steeply upwards.</p>
<p>If, instead of checking if a direction just goes up, you want to see if it's
vertical (up <em>or</em> down), you can use <code>dir.y &gt; 0.9 or dir.y &lt; -0.9</code>.
It's a lot shorter if you use the
<a href="#overview-of-global-functions">abs function</a> (which turns negative numbers
into positive numbers): <code>abs(dir.y) &gt; 0.9</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Short description</th></tr></thead><tbody>
<tr><td>x</td><td>number</td><td>The x-coordinate. By Godot conventions, the x-axis goes to the right (or to the East)</td></tr>
<tr><td>y</td><td>number</td><td>The y-coordinate. By Godot conventions, the y-axis goes up in 3D and down in 2D.</td></tr>
<tr><td>z</td><td>number</td><td>The z-coordinate. Only for Vector3. By Godot conventions, the z-axis goes backward (or to the South)</td></tr>
<tr><td>length</td><td>number</td><td>The length of the vector.</td></tr>
<tr><td>dot(vector)</td><td>number</td><td>The dot product. If you don't know it, you won't need it.</td></tr>
<tr><td>cross(Vector3)</td><td>Vector3</td><td>Only for Vector3. The cross product. If you don't know it, you won't need it.</td></tr>
</tbody></table>
</div>
<p>Also relevant is the global function
“<a href="#overview-of-global-functions">normalize(vector)</a>”,
which changes a vector's length to 1.</p>
<p>Here's an overview of the math expressions that are supported for vectors:</p>
<div class="table-wrapper"><table><thead><tr><th>Mathematical expression</th><th>Result</th><th>Short description</th></tr></thead><tbody>
<tr><td>vector + vector</td><td>vector</td><td>Adds the elements of the vectors together, like this: (x1 + x2, y1 + y2, z1 + z2)</td></tr>
<tr><td>vector - vector</td><td>vector</td><td>Subtracts the elements of the vectors. If you do this with two position vectors, you get the difference in position.</td></tr>
<tr><td>vector * vector</td><td>vector</td><td>Multiplies the elements of the vectors. This is element-wise multiplication (I mention that because there's a bunch of different ways to multiply vectors).</td></tr>
<tr><td>vector / vector</td><td>vector</td><td>Divides the elements of the vectors. Element-wise division.</td></tr>
<tr><td>vector + number</td><td>vector</td><td>Adds the number to each element of the vector.</td></tr>
<tr><td>vector - number</td><td>vector</td><td>Subtracts the number from each element of the vector.</td></tr>
<tr><td>vector * number</td><td>vector</td><td>Multiplies each element of the vector by the number.</td></tr>
<tr><td>vector / number</td><td>vector</td><td>Divides each element of the vector by the number.</td></tr>
</tbody></table>
</div>
<p>The scripting language also supports vector swizzling.
Vector swizzling lets you reorder the elements of vectors very conveniently,
though if you haven't already heard of vector swizzling,
you probably won't need it while using AutoTrimmer.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rulebook/trim_group_config.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rulebook/trim_group_config.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
